// Generated by BUCKLESCRIPT VERSION 5.0.4, PLEASE EDIT WITH CARE
'use strict';

var Css = require("bs-css/src/Css.js");
var Rust = require("./Rust.bs.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Hooks = require("./Hooks.bs.js");
var React = require("react");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var TypeSerde = require("./TypeSerde.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var ReactDOMRe = require("reason-react/src/ReactDOMRe.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Localforage = require("localforage");
var Belt_MapString = require("bs-platform/lib/js/belt_MapString.js");
var Belt_SetString = require("bs-platform/lib/js/belt_SetString.js");

function let_(v, fn) {
  return v.then(Curry.__1(fn));
}

function resolve(prim) {
  return Promise.resolve(prim);
}

var Async = /* module */[
  /* let_ */let_,
  /* resolve */resolve
];

function sceneFromKey(key) {
  var m = key.split(":");
  var exit = 0;
  if (m.length !== 3) {
    exit = 1;
  } else {
    var created = m[0];
    var id = m[1];
    var match = m[2];
    if (match === "image") {
      return /* record */[
              /* id */created + (":" + id),
              /* modified */Caml_format.caml_float_of_string(created),
              /* created */Caml_format.caml_float_of_string(created),
              /* title */undefined,
              /* tags */Belt_SetString.empty,
              /* children : array */[],
              /* parent */undefined
            ];
    } else {
      exit = 1;
    }
  }
  if (exit === 1) {
    console.log(m);
    return Pervasives.failwith("Bad key " + key);
  }
  
}

function getSceneInfo(param) {
  var v = Localforage.getItem("scenes");
  return v.then((function (sceneRaw) {
                if (sceneRaw == null) {
                  var v = Localforage.keys();
                  return v.then((function (keys) {
                                return Promise.resolve(/* record */[
                                            /* scenes */Belt_MapString.fromArray(Belt_Array.map(Belt_Array.keep(keys, (function (m) {
                                                            return m.endsWith(":image");
                                                          })), (function (key) {
                                                        var scene = sceneFromKey(key);
                                                        return /* tuple */[
                                                                scene[/* id */0],
                                                                scene
                                                              ];
                                                      }))),
                                            /* tags */Belt_MapString.empty
                                          ]);
                              }));
                } else {
                  var match = TypeSerde.deserializeDirectory(sceneRaw);
                  if (match.tag) {
                    return Pervasives.failwith("Invalid scene data: " + $$String.concat(" : ", match[0]));
                  } else {
                    return Promise.resolve(match[0]);
                  }
                }
              }));
}

function App$Scene(Props) {
  var scene = Props.scene;
  var key = scene[/* id */0] + ":image";
  var getter = React.useCallback((function (param) {
          return Localforage.getItem(key);
        }), /* array */[key]);
  var imageBlob = Hooks.useLoading(getter);
  var url = React.useMemo((function () {
          if (imageBlob !== undefined) {
            var blob = Caml_option.valFromOption(imageBlob);
            if (blob == null) {
              return "invalid";
            } else {
              return URL.createObjectURL(blob);
            }
          }
          
        }), /* array */[imageBlob]);
  if (url !== undefined) {
    var match = scene[/* children */5].length === 0;
    return React.createElement("div", {
                className: Css.style(/* :: */[
                      Css.display(/* flex */-1010954439),
                      /* :: */[
                        Css.flexDirection(/* row */5693978),
                        /* :: */[
                          Css.padding(Css.px(4)),
                          /* [] */0
                        ]
                      ]
                    ])
              }, React.createElement("div", {
                    className: Css.style(/* :: */[
                          Css.width(Css.px(50)),
                          /* :: */[
                            Css.backgroundColor(Css.black),
                            /* :: */[
                              Css.height(Css.px(50)),
                              /* :: */[
                                Css.backgroundSize(/* cover */-899416265),
                                /* :: */[
                                  /* `declaration */[
                                    -434952966,
                                    /* tuple */[
                                      "background-position",
                                      "center"
                                    ]
                                  ],
                                  /* [] */0
                                ]
                              ]
                            ]
                          ]
                        ]),
                    style: {
                      backgroundImage: "url(" + (url + ")")
                    }
                  }), match ? null : React.createElement("div", undefined, Belt_Array.map(scene[/* children */5], (function (key) {
                            return React.createElement("div", undefined, key);
                          }))));
  } else {
    return React.createElement("div", undefined, "Loading...");
  }
}

var Scene = /* module */[/* make */App$Scene];

function force(m) {
  if (m !== undefined) {
    return Caml_option.valFromOption(m);
  } else {
    return Pervasives.failwith("unwrapping option");
  }
}

var Opt = /* module */[/* force */force];

function App$ScenePicker(Props) {
  var scenes = Props.scenes;
  Props.tags;
  return React.createElement("div", undefined, Belt_Array.map(Belt_MapString.toArray(scenes), (function (param) {
                    return React.createElement("div", undefined, React.createElement(App$Scene, {
                                    scene: param[1]
                                  }));
                  })));
}

var ScenePicker = /* module */[/* make */App$ScenePicker];

function App$ConfigEditor(Props) {
  var config = Props.config;
  Props.update;
  var match = Hooks.useState(config);
  var setTmpConfig = match[1];
  var tmpConfig = match[0];
  React.useEffect((function () {
          if (Caml_obj.caml_notequal(config, tmpConfig)) {
            Curry._1(setTmpConfig, config);
          }
          return undefined;
        }), /* array */[config]);
  return React.createElement("div", {
              className: Css.style(/* :: */[
                    Css.fontFamily("monospace"),
                    /* :: */[
                      Css.whiteSpace(/* pre */5595171),
                      /* [] */0
                    ]
                  ])
            }, force(Caml_option.undefined_to_opt(JSON.stringify(tmpConfig))));
}

var ConfigEditor = /* module */[/* make */App$ConfigEditor];

function getKeys(param) {
  return Localforage.keys();
}

function App$App(Props) {
  var wasm = Props.wasm;
  var keys = Hooks.useLoading(getSceneInfo);
  var match = Hooks.useState(wasm.initial());
  var onChange = match[1];
  var config = match[0];
  console.log("Rendering app here");
  React.useEffect((function () {
          wasm.setup(config, onChange);
          return undefined;
        }), ([]));
  if (keys !== undefined) {
    var match$1 = keys;
    return React.createElement("div", undefined, React.createElement(App$ConfigEditor, {
                    config: config,
                    update: (function (config) {
                        return wasm.restore(config);
                      })
                  }), React.createElement(App$ScenePicker, {
                    scenes: match$1[/* scenes */0],
                    tags: match$1[/* tags */1]
                  }));
  } else {
    return React.createElement("div", undefined, "Loading");
  }
}

var App = /* module */[
  /* getKeys */getKeys,
  /* make */App$App
];

Rust.withModule((function (wasm) {
        return ReactDOMRe.renderToElementWithId(React.createElement(App$App, {
                        wasm: wasm
                      }), "reason-root");
      }));

var x = 10;

exports.x = x;
exports.Async = Async;
exports.sceneFromKey = sceneFromKey;
exports.getSceneInfo = getSceneInfo;
exports.Scene = Scene;
exports.Opt = Opt;
exports.ScenePicker = ScenePicker;
exports.ConfigEditor = ConfigEditor;
exports.App = App;
/*  Not a pure module */
